# 07 数据传递机制

本章聚焦数据如何在浏览器、React 组件、Next.js API、文件系统之间流动，构建完整闭环。

## 1. 前后端数据流总体图
- 客户端：`page.tsx` → `fetch('/api/feishu/classic-quotes')` → 映射为 `Quote[]` → 展示与收藏。
- 服务端：`route.ts` → 拉取飞书字段与记录 → 映射为统一 `quotes` → 写入 `classic-quotes.json` → 返回给客户端。
- 本地缓存：`classic-quotes.json` 存放在工具目录，供非刷新请求直接读取。

## 2. 请求与响应结构约定
- 请求：`
  - `GET /api/feishu/classic-quotes`
  - `GET /api/feishu/classic-quotes?refresh=1`（强制刷新）
- 响应：
```json
{
  "source": "feishu-bitable",
  "updatedAt": "ISO 时间字符串",
  "schema": [ { "id": "fld...", "name": "sentence", "type": "text" }, ... ],
  "records": [ { "record_id": "rec...", "fields": { "sentence": "..." } }, ... ],
  "quotes": [ { "id": 1, "text": "...", "author": "...", "category": "..." }, ... ]
}
```

## 3. 客户端映射与回退策略
- 优先使用远端 `quotes`；为空时回退到内置 `QUOTES`：
```ts
const filtered = () => (remoteQuotes && remoteQuotes.length ? remoteQuotes : QUOTES)
```
- 客户端映射时强制字符串化并过滤空文本，保证渲染安全：
```ts
const mapped: Quote[] = list.map((it, i) => ({
  id: typeof it.id === 'number' ? it.id : (typeof it.id === 'string' ? Number(it.id) || i + 1 : i + 1),
  text: String(it.text ?? ''),
  author: String(it.author ?? ''),
  category: String(it.category ?? ''),
})).filter(q => q.text.length > 0)
```

## 4. 服务端映射与容错
- 统一字段名称映射，避免 `toLowerCase` 调用在 `undefined` 上：
```ts
const lower = (v: unknown) => typeof v === 'string' ? v.toLowerCase() : ''
```
- 根据候选字段选择 `text`、`author`、`category`，并生成稳定 `id`：
```ts
// 伪码示例
const text = fields['sentence'] || fields['text'] || fields['source'] || ''
const author = fields['author'] || fields['source'] || ''
const category = fields['type'] || fields['category'] || ''
```

## 5. 文件系统与工具内聚
- 将数据文件存放在工具目录：`src/app/tools/classic-quotes/classic-quotes.json`。
- 非刷新模式优先从本地文件读取，避免频繁外部请求，提升性能与稳定性。

## 6. 用户行为对数据流的影响
- 收藏：仅在客户端持久化到 `localStorage`，不回写到服务端。
- 自动刷新：周期性请求 `?refresh=1`，促使服务端写入最新数据并返回。

## 7. 最佳实践
- 前后端统一使用稳定的响应结构与类型定义，简化调试与联动。
- 所有映射过程均防御式编程（空值、类型不匹配、降级策略）。
- 工具级目录内聚让迁移与维护成本更低。

---
**要点回顾**
- 明确的请求/响应契约与统一映射是数据传递的核心。
- 前端回退策略与服务端本地缓存共同保证用户体验与可用性。