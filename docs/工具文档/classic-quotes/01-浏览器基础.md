# 01 浏览器基础

本章面向零基础，结合项目实际说明浏览器如何为页面提供渲染、交互、存储与网络能力。

## 1. 页面生命周期与渲染
- 浏览器解析 HTML → 构建 **DOM 树** → 加载 CSS 构建 **渲染树** → 布局与绘制。
- React 通过虚拟 DOM 管理变更，浏览器最终负责实际渲染。

示例：在 React 中等待页面挂载后进行初始化拉取远端数据。
```tsx
useEffect(() => {
  // 页面首次挂载后执行
  fetchFeishu(false)
}, [])
```

## 2. 事件与交互
- 浏览器提供事件系统（点击、输入、滚动）；React 将其封装为合成事件。
- 交互示例：按钮点击后触发语录获取与加载态显示。
```tsx
const fetchQuote = () => {
  setLoading(true)
  const arr = filtered()
  if (!arr.length) { setErr('📭 暂无语录数据'); setLoading(false); return }
  const picked = arr[Math.floor(Math.random()*arr.length)]
  setQ(picked)
  setLoading(false)
}
```

## 3. 本地存储（localStorage）
- 浏览器提供 `localStorage`/`sessionStorage` 持久化轻量数据。
- 在工具页中，收藏列表 `favIds` 被持久化：
```tsx
useEffect(() => { // 读取收藏
  try { const raw = localStorage.getItem('classic_quotes_favs'); if (raw) setFavIds(JSON.parse(raw)) } catch {}
}, [])
useEffect(() => { // 保存收藏
  try { localStorage.setItem('classic_quotes_favs', JSON.stringify(favIds)) } catch {}
}, [favIds])
```
最佳实践：
- 使用 `try/catch` 处理 JSON 解析错误与隐私模式限制。
- 约定稳定的存储键名，如 `classic_quotes_favs`。

## 4. 网络请求（fetch）与缓存
- 浏览器提供 `fetch` 进行 HTTP 请求；可设置 `cache: 'no-store'` 禁用缓存。
- 项目中从 API 拉取数据：
```tsx
const resp = await fetch('/api/feishu/classic-quotes', { cache: 'no-store' })
const data = await resp.json()
if (!resp.ok || data.error) throw new Error(data.error || 'Feishu API error')
```
最佳实践：
- 明确错误处理，避免 UI 无反馈。
- 探测网络慢（例如通过时间阈值标记 `slow`），给用户提示。

## 5. 定时任务与资源释放
- 浏览器提供 `setInterval` 与 `clearInterval`。
- 自动刷新远端数据，组件卸载时清理：
```tsx
useEffect(() => {
  const t = window.setInterval(() => fetchFeishu(true), 60000)
  return () => window.clearInterval(t)
}, [])
```

## 6. 动画与体验
- 可使用 CSS/JS 动画库（如 `gsap`）提升体验。
- 项目中通过 `swayRef` 存储动画句柄，避免重复创建与内存泄漏。

## 7. 安全与性能提示
- 仅存储必要数据到 `localStorage`，避免隐私风险。
- 对网络请求设置合理的错误提示与重试策略。
- 渲染前校验数据（如空数组），避免报错与闪退。

---
**要点回顾**
- 组件挂载时发起初始化请求，合成事件处理用户交互。
- 使用 `localStorage` 持久化收藏，处理异常与兼容性。
- 通过 `fetch` 拉取数据并明确错误处理，定时刷新保持实时性。