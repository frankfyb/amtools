# 06 状态管理方案

在本工具中，状态管理以 React Hooks 为主，针对收藏、加载态、错误、远端数据等做了精细化设计。

## 1. 状态分类
- **数据状态**：`remoteQuotes`、`q`（当前展示语录）。
- **UI 状态**：`loading`、`err`、`slow`、`anim`。
- **系统状态**：`api`（'connecting' | 'ok' | 'error'）。
- **用户偏好**：`favIds`、`auto`、`favView`。

## 2. 初始化与持久化
- 初始化从远端拉取数据、读取收藏；收藏变更时写入本地存储：
```tsx
useEffect(() => { fetchFeishu(false) }, [])
useEffect(() => { const t = window.setInterval(() => fetchFeishu(true), 60000); return () => window.clearInterval(t) }, [])
useEffect(() => { try { const raw = localStorage.getItem('classic_quotes_favs'); if (raw) setFavIds(JSON.parse(raw)) } catch {} }, [])
useEffect(() => { try { localStorage.setItem('classic_quotes_favs', JSON.stringify(favIds)) } catch {} }, [favIds])
```

## 3. 数据源选择
- 使用统一函数选择当前数据源，保持逻辑集中：
```ts
const filtered = () => (remoteQuotes && remoteQuotes.length ? remoteQuotes : QUOTES)
```
- 收藏列表从当前数据源筛选，保证远端收藏也可见。

## 4. 交互驱动状态变更
- `fetchQuote()` 控制加载与错误态，并随机选择语录：
```tsx
const fetchQuote = () => {
  setLoading(true); setSlow(false); setErr(null)
  const arr = filtered()
  if (!arr.length) { setErr('📭 暂无语录数据'); setLoading(false); return }
  const picked = arr[Math.floor(Math.random()*arr.length)]
  setQ(picked); setLoading(false)
}
```
- 收藏按钮根据选中状态动态改变颜色（高亮），提供即时反馈。

## 5. 最佳实践
- 将“数据获取”与“数据展示”分离：`fetchFeishu()` 负责拉取并映射，`fetchQuote()` 负责选择与展示。
- 统一从 `filtered()` 读取数据，减少重复判断与差错。
- 所有副作用均设置清理逻辑，避免内存泄漏（如定时器）。

## 6. 可扩展建议
- 中型项目可引入轻量状态库（如 `zustand`）隔离数据层，便于跨组件共享。
- 大型项目应设计模块化 store 与选择器（selectors），减少渲染与耦合。

---
**要点回顾**
- 清晰的状态分类与集中数据源选择是简洁可靠的关键。
- 交互驱动的状态变更要配合加载、错误态与用户反馈。