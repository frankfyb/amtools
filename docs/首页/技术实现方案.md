# AI工具导航首页 - 技术实现方案

## 1. 系统架构设计

### 1.1 整体架构概览
```
┌─────────────────────────────────────────────────────────────┐
│                    用户界面层 (UI Layer)                      │
├─────────────────────────────────────────────────────────────┤
│  Header Navigation  │  Sidebar (Desktop)  │  Main Content   │
│  - Brand Logo       │  - Category Filter  │  - Tool Grid    │
│  - Navigation Menu  │  - Tool Counter     │  - Loading State │
│  - User Actions     │  - Active State     │  - Empty State   │
└─────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────┐
│                   组件层 (Component Layer)                   │
├─────────────────────────────────────────────────────────────┤
│  ToolCard Component │  CategoryButton     │  LoadingSkeleton │
│  - Tool Information │  - Filter Logic     │  - Animation     │
│  - Interaction      │  - State Management │  - Placeholder   │
│  - Visual Effects   │  - Count Display    │  - Responsive    │
└─────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────┐
│                   状态管理层 (State Layer)                    │
├─────────────────────────────────────────────────────────────┤
│  React State        │  Local Storage      │  URL Parameters  │
│  - selectedCategory │  - User Preferences │  - Filter State  │
│  - isLoading        │  - Theme Settings   │  - Search Query  │
│  - toolsData        │  - Recent Visits    │  - Page State    │
└─────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────┐
│                   数据层 (Data Layer)                        │
├─────────────────────────────────────────────────────────────┤
│  Static Data        │  API Integration    │  Cache Layer     │
│  - Tools Database   │  - External APIs    │  - Browser Cache │
│  - Categories       │  - Analytics        │  - Memory Cache  │
│  - Configuration    │  - User Tracking    │  - Service Worker│
└─────────────────────────────────────────────────────────────┘
```

### 1.2 技术栈架构
```
Frontend Architecture:
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Next.js 14+   │────│   React 18+     │────│  TypeScript     │
│   - App Router  │    │   - Hooks       │    │   - Type Safety │
│   - SSR/SSG     │    │   - Suspense    │    │   - Interfaces  │
│   - Optimization│    │   - Concurrent  │    │   - Generics    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  Tailwind CSS   │────│   PostCSS       │────│   Autoprefixer  │
│   - Utility     │    │   - Processing  │    │   - Browser     │
│   - Responsive  │    │   - Plugins     │    │   - Compatibility│
│   - Custom      │    │   - Optimization│    │   - Vendor      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 1.3 组件架构设计
```
Component Hierarchy:
HomePage
├── Header
│   ├── BrandLogo
│   ├── Navigation (Desktop)
│   └── UserActions
├── MobileNavigation
│   ├── CategoryTabs
│   └── ScrollableList
├── Sidebar (Desktop)
│   ├── CategoryList
│   └── CategoryButton[]
├── MainContent
│   ├── PageHeader
│   ├── ToolsGrid
│   │   ├── ToolCard[]
│   │   ├── LoadingSkeleton[]
│   │   └── EmptyState
│   └── Footer
└── GlobalComponents
    ├── LoadingSpinner
    ├── ErrorBoundary
    └── SEOHead
```

## 2. 核心功能实现

### 2.1 状态管理实现
```typescript
// 主要状态管理
interface HomePageState {
  selectedCategory: string;
  isLoading: boolean;
  tools: Tool[];
  categories: Category[];
  filteredTools: Tool[];
}

// 状态管理Hook
function useHomePageState() {
  const [selectedCategory, setSelectedCategory] = useState('全部');
  const [isLoading, setIsLoading] = useState(true);
  
  // 工具数据
  const toolsData = useMemo(() => getToolsData(), []);
  
  // 分类数据
  const categories = useMemo(() => {
    return getCategoriesWithCount(toolsData);
  }, [toolsData]);
  
  // 筛选逻辑
  const filteredTools = useMemo(() => {
    return selectedCategory === '全部' 
      ? toolsData 
      : toolsData.filter(tool => tool.category === selectedCategory);
  }, [toolsData, selectedCategory]);
  
  // 加载状态模拟
  useEffect(() => {
    const timer = setTimeout(() => setIsLoading(false), 1500);
    return () => clearTimeout(timer);
  }, []);
  
  return {
    selectedCategory,
    setSelectedCategory,
    isLoading,
    tools: toolsData,
    categories,
    filteredTools
  };
}
```

### 2.2 响应式布局实现
```typescript
// 响应式断点配置
const breakpoints = {
  sm: '640px',   // 移动端
  md: '768px',   // 平板端
  lg: '1024px',  // 桌面端
  xl: '1280px',  // 大屏幕
  '2xl': '1536px' // 超大屏幕
};

// 响应式Hook
function useResponsive() {
  const [screenSize, setScreenSize] = useState<'mobile' | 'tablet' | 'desktop'>('desktop');
  
  useEffect(() => {
    const checkScreenSize = () => {
      const width = window.innerWidth;
      if (width < 768) {
        setScreenSize('mobile');
      } else if (width < 1024) {
        setScreenSize('tablet');
      } else {
        setScreenSize('desktop');
      }
    };
    
    checkScreenSize();
    window.addEventListener('resize', checkScreenSize);
    return () => window.removeEventListener('resize', checkScreenSize);
  }, []);
  
  return screenSize;
}

// 响应式网格配置
const gridConfig = {
  mobile: 'grid-cols-1',
  tablet: 'grid-cols-2',
  desktop: 'grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5'
};
```

### 2.3 工具卡片组件实现
```typescript
interface ToolCardProps {
  tool: Tool;
  index?: number;
}

export function ToolCard({ tool, index = 0 }: ToolCardProps) {
  const [isHovered, setIsHovered] = useState(false);
  
  // 动画延迟计算
  const animationDelay = `${index * 100}ms`;
  
  // 点击处理
  const handleClick = useCallback(() => {
    // 统计点击事件
    trackToolClick(tool.id);
    
    // 跳转到工具页面
    if (tool.url.startsWith('/')) {
      // 内部链接
      window.location.href = tool.url;
    } else {
      // 外部链接
      window.open(tool.url, '_blank', 'noopener,noreferrer');
    }
  }, [tool]);
  
  // 键盘导航支持
  const handleKeyDown = useCallback((e: KeyboardEvent) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      handleClick();
    }
  }, [handleClick]);
  
  return (
    <article
      className={clsx(
        // 基础样式
        'bg-white/80 backdrop-blur-sm rounded-2xl border border-slate-200/60',
        'shadow-sm hover:shadow-xl hover:shadow-slate-200/50',
        'transition-all duration-300 p-6 group cursor-pointer',
        // 交互样式
        'hover:border-indigo-200 hover:-translate-y-1',
        // 焦点样式
        'focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2'
      )}
      style={{ animationDelay }}
      onClick={handleClick}
      onKeyDown={handleKeyDown}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      tabIndex={0}
      role="button"
      aria-label={`访问${tool.name} - ${tool.description}`}
    >
      {/* 卡片头部 */}
      <header className="flex items-center justify-between mb-5">
        <ToolIcon 
          icon={tool.icon} 
          name={tool.name}
          animated={isHovered}
        />
        <ToolBadges 
          visits={tool.visits}
          hot={tool.hot}
          new={tool.new}
        />
      </header>
      
      {/* 工具信息 */}
      <div className="mb-5">
        <h3 className="text-lg font-bold text-slate-800 mb-3 group-hover:text-indigo-600 transition-colors">
          {tool.name}
        </h3>
        <p className="text-slate-600 text-sm leading-relaxed line-clamp-3">
          {tool.description}
        </p>
      </div>
      
      {/* 工具标签 */}
      <ToolTags category={tool.category} tags={tool.tags} />
      
      {/* 访问按钮 */}
      <ToolAccessButton 
        url={tool.url}
        isHovered={isHovered}
      />
    </article>
  );
}
```

### 2.4 分类筛选实现
```typescript
// 分类按钮组件
interface CategoryButtonProps {
  category: CategoryWithCount;
  isSelected: boolean;
  onClick: (categoryName: string) => void;
  index?: number;
}

export function CategoryButton({ 
  category, 
  isSelected, 
  onClick, 
  index = 0 
}: CategoryButtonProps) {
  const animationDelay = `${index * 100}ms`;
  
  return (
    <button
      className={clsx(
        // 基础样式
        'w-full text-left px-4 py-3 text-sm rounded-xl',
        'transition-all duration-300 font-medium',
        'hover:scale-105 active:scale-95',
        // 选中状态
        isSelected ? [
          'bg-gradient-to-r from-indigo-500 via-blue-500 to-cyan-500',
          'text-white shadow-lg shadow-indigo-500/25'
        ] : [
          'text-slate-700 hover:bg-slate-100 hover:shadow-md'
        ]
      )}
      style={{ animationDelay }}
      onClick={() => onClick(category.name)}
      aria-pressed={isSelected}
      aria-label={`选择${category.name}分类，共${category.count}个工具`}
    >
      <span className="transition-all duration-200">
        {category.name}
      </span>
      <span className={clsx(
        'text-xs px-2 py-1 rounded-lg font-medium ml-2',
        'transition-all duration-200',
        isSelected ? [
          'bg-white/20 text-white scale-105'
        ] : [
          'bg-slate-200 text-slate-600 group-hover:bg-slate-300'
        ]
      )}>
        {category.count}
      </span>
    </button>
  );
}

// 分类筛选逻辑
function useCategoryFilter(tools: Tool[]) {
  const [selectedCategory, setSelectedCategory] = useState('全部');
  
  // 计算分类统计
  const categoriesWithCount = useMemo(() => {
    const baseCategories = [
      { id: '1', name: '全部' },
      { id: '2', name: 'AI写作' },
      { id: '3', name: 'AI绘画' },
      // ... 其他分类
    ];
    
    return baseCategories.map(category => ({
      ...category,
      count: category.name === '全部' 
        ? tools.length 
        : tools.filter(tool => tool.category === category.name).length
    }));
  }, [tools]);
  
  // 筛选工具
  const filteredTools = useMemo(() => {
    return selectedCategory === '全部'
      ? tools
      : tools.filter(tool => tool.category === selectedCategory);
  }, [tools, selectedCategory]);
  
  return {
    selectedCategory,
    setSelectedCategory,
    categoriesWithCount,
    filteredTools
  };
}
```

## 3. 性能优化实现

### 3.1 渲染优化
```typescript
// 工具卡片优化
export const ToolCard = React.memo(function ToolCard({ tool }: ToolCardProps) {
  // 组件实现
}, (prevProps, nextProps) => {
  // 自定义比较函数
  return prevProps.tool.id === nextProps.tool.id;
});

// 分类按钮优化
export const CategoryButton = React.memo(function CategoryButton({ 
  category, 
  isSelected, 
  onClick 
}: CategoryButtonProps) {
  // 使用useCallback优化点击处理
  const handleClick = useCallback(() => {
    onClick(category.name);
  }, [category.name, onClick]);
  
  return (
    <button onClick={handleClick}>
      {/* 按钮内容 */}
    </button>
  );
});

// 主页面组件优化
export default function Home() {
  // 优化分类切换函数
  const handleCategoryChange = useCallback((categoryName: string) => {
    setSelectedCategory(categoryName);
    
    // 更新URL参数（可选）
    const url = new URL(window.location.href);
    url.searchParams.set('category', categoryName);
    window.history.replaceState({}, '', url.toString());
  }, []);
  
  // 优化工具数据计算
  const toolsData = useMemo(() => {
    return getStaticToolsData(); // 静态数据，避免重复计算
  }, []);
  
  // 优化筛选逻辑
  const filteredTools = useMemo(() => {
    return selectedCategory === '全部'
      ? toolsData
      : toolsData.filter(tool => tool.category === selectedCategory);
  }, [toolsData, selectedCategory]);
  
  return (
    <div>
      {/* 页面内容 */}
    </div>
  );
}
```

### 3.2 加载性能优化
```typescript
// 图片懒加载实现
function LazyImage({ src, alt, ...props }: ImageProps) {
  const [isLoaded, setIsLoaded] = useState(false);
  const [isInView, setIsInView] = useState(false);
  const imgRef = useRef<HTMLImageElement>(null);
  
  // Intersection Observer
  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsInView(true);
          observer.disconnect();
        }
      },
      { threshold: 0.1 }
    );
    
    if (imgRef.current) {
      observer.observe(imgRef.current);
    }
    
    return () => observer.disconnect();
  }, []);
  
  return (
    <div ref={imgRef} className="relative">
      {isInView && (
        <img
          src={src}
          alt={alt}
          onLoad={() => setIsLoaded(true)}
          className={clsx(
            'transition-opacity duration-300',
            isLoaded ? 'opacity-100' : 'opacity-0'
          )}
          {...props}
        />
      )}
      {!isLoaded && (
        <div className="absolute inset-0 bg-slate-200 animate-pulse rounded" />
      )}
    </div>
  );
}

// 代码分割实现
const LazyToolDetails = dynamic(() => import('./ToolDetails'), {
  loading: () => <ToolDetailsSkeleton />,
  ssr: false
});

// 预加载关键资源
function preloadCriticalResources() {
  // 预加载关键CSS
  const link = document.createElement('link');
  link.rel = 'preload';
  link.as = 'style';
  link.href = '/critical.css';
  document.head.appendChild(link);
  
  // 预加载关键字体
  const fontLink = document.createElement('link');
  fontLink.rel = 'preload';
  fontLink.as = 'font';
  fontLink.type = 'font/woff2';
  fontLink.href = '/fonts/inter.woff2';
  fontLink.crossOrigin = 'anonymous';
  document.head.appendChild(fontLink);
}
```

### 3.3 缓存策略实现
```typescript
// 内存缓存实现
class MemoryCache<T> {
  private cache = new Map<string, { data: T; timestamp: number }>();
  private ttl: number;
  
  constructor(ttlMinutes = 30) {
    this.ttl = ttlMinutes * 60 * 1000;
  }
  
  set(key: string, data: T): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    });
  }
  
  get(key: string): T | null {
    const item = this.cache.get(key);
    if (!item) return null;
    
    if (Date.now() - item.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }
    
    return item.data;
  }
  
  clear(): void {
    this.cache.clear();
  }
}

// 使用缓存
const toolsCache = new MemoryCache<Tool[]>(60); // 60分钟缓存

function useToolsData() {
  const [tools, setTools] = useState<Tool[]>([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // 尝试从缓存获取
    const cachedTools = toolsCache.get('tools');
    if (cachedTools) {
      setTools(cachedTools);
      setLoading(false);
      return;
    }
    
    // 从API获取数据
    fetchToolsData()
      .then(data => {
        setTools(data);
        toolsCache.set('tools', data);
      })
      .finally(() => setLoading(false));
  }, []);
  
  return { tools, loading };
}
```

## 4. 动画和交互实现

### 4.1 页面加载动画
```typescript
// 加载骨架屏组件
function LoadingSkeleton() {
  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6 sm:gap-8">
      {[...Array(8)].map((_, index) => (
        <div 
          key={index}
          className="bg-white/80 backdrop-blur-sm rounded-2xl p-6 border border-slate-200/60 shadow-sm animate-pulse"
          style={{
            animationDelay: `${index * 100}ms`,
            animationDuration: '1.5s'
          }}
        >
          {/* 头部骨架 */}
          <div className="flex items-center justify-between mb-5">
            <div className="w-12 h-12 sm:w-14 sm:h-14 bg-gradient-to-br from-slate-200 to-slate-300 rounded-xl animate-pulse"></div>
            <div className="w-16 h-6 bg-slate-200 rounded-lg animate-pulse"></div>
          </div>
          
          {/* 内容骨架 */}
          <div className="mb-5">
            <div className="h-6 bg-slate-200 rounded-lg mb-3 animate-pulse"></div>
            <div className="space-y-2">
              <div className="h-4 bg-slate-200 rounded animate-pulse"></div>
              <div className="h-4 bg-slate-200 rounded w-3/4 animate-pulse"></div>
            </div>
          </div>
          
          {/* 按钮骨架 */}
          <div className="w-full h-12 bg-gradient-to-r from-slate-200 to-slate-300 rounded-xl animate-pulse"></div>
        </div>
      ))}
    </div>
  );
}

// 渐入动画Hook
function useFadeInAnimation(delay = 0) {
  const [isVisible, setIsVisible] = useState(false);
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setIsVisible(true);
    }, delay);
    
    return () => clearTimeout(timer);
  }, [delay]);
  
  return {
    className: clsx(
      'transition-all duration-700 ease-out',
      isVisible 
        ? 'opacity-100 translate-y-0' 
        : 'opacity-0 translate-y-4'
    )
  };
}
```

### 4.2 交互动画实现
```typescript
// 悬停效果Hook
function useHoverAnimation() {
  const [isHovered, setIsHovered] = useState(false);
  
  const hoverProps = {
    onMouseEnter: () => setIsHovered(true),
    onMouseLeave: () => setIsHovered(false),
  };
  
  const hoverClasses = clsx(
    'transition-all duration-300 ease-out',
    isHovered && 'transform hover:scale-105 hover:-translate-y-1'
  );
  
  return { isHovered, hoverProps, hoverClasses };
}

// 点击波纹效果
function useRippleEffect() {
  const [ripples, setRipples] = useState<Array<{ id: number; x: number; y: number }>>([]);
  
  const createRipple = useCallback((event: React.MouseEvent) => {
    const rect = event.currentTarget.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    
    const newRipple = {
      id: Date.now(),
      x,
      y
    };
    
    setRipples(prev => [...prev, newRipple]);
    
    // 清理波纹
    setTimeout(() => {
      setRipples(prev => prev.filter(ripple => ripple.id !== newRipple.id));
    }, 600);
  }, []);
  
  return { ripples, createRipple };
}

// 滚动视差效果
function useParallaxEffect(speed = 0.5) {
  const [offset, setOffset] = useState(0);
  
  useEffect(() => {
    const handleScroll = () => {
      setOffset(window.pageYOffset * speed);
    };
    
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, [speed]);
  
  return { transform: `translateY(${offset}px)` };
}
```

## 5. 无障碍访问实现

### 5.1 键盘导航
```typescript
// 键盘导航Hook
function useKeyboardNavigation(items: any[], onSelect: (item: any) => void) {
  const [focusedIndex, setFocusedIndex] = useState(-1);
  
  const handleKeyDown = useCallback((event: KeyboardEvent) => {
    switch (event.key) {
      case 'ArrowDown':
        event.preventDefault();
        setFocusedIndex(prev => 
          prev < items.length - 1 ? prev + 1 : 0
        );
        break;
        
      case 'ArrowUp':
        event.preventDefault();
        setFocusedIndex(prev => 
          prev > 0 ? prev - 1 : items.length - 1
        );
        break;
        
      case 'Enter':
      case ' ':
        event.preventDefault();
        if (focusedIndex >= 0) {
          onSelect(items[focusedIndex]);
        }
        break;
        
      case 'Escape':
        setFocusedIndex(-1);
        break;
    }
  }, [items, focusedIndex, onSelect]);
  
  useEffect(() => {
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [handleKeyDown]);
  
  return { focusedIndex, setFocusedIndex };
}

// ARIA标签实现
function ToolCardWithA11y({ tool }: { tool: Tool }) {
  const cardId = `tool-card-${tool.id}`;
  const descriptionId = `tool-description-${tool.id}`;
  
  return (
    <article
      id={cardId}
      role="button"
      tabIndex={0}
      aria-labelledby={`${cardId}-title`}
      aria-describedby={descriptionId}
      aria-pressed={false}
      className="tool-card"
    >
      <h3 id={`${cardId}-title`} className="tool-title">
        {tool.name}
      </h3>
      <p id={descriptionId} className="tool-description">
        {tool.description}
      </p>
      
      {/* 屏幕阅读器专用文本 */}
      <span className="sr-only">
        按回车键或空格键访问 {tool.name}
      </span>
    </article>
  );
}
```

### 5.2 屏幕阅读器支持
```typescript
// 动态公告组件
function LiveRegion({ message }: { message: string }) {
  return (
    <div
      role="status"
      aria-live="polite"
      aria-atomic="true"
      className="sr-only"
    >
      {message}
    </div>
  );
}

// 使用示例
function HomePage() {
  const [announcement, setAnnouncement] = useState('');
  
  const handleCategoryChange = (category: string) => {
    setSelectedCategory(category);
    setAnnouncement(`已切换到${category}分类，共${filteredTools.length}个工具`);
  };
  
  return (
    <div>
      <LiveRegion message={announcement} />
      {/* 其他内容 */}
    </div>
  );
}
```

## 6. SEO优化实现

### 6.1 元数据优化
```typescript
// SEO组件
function SEOHead({ 
  title, 
  description, 
  keywords,
  canonical 
}: SEOProps) {
  return (
    <Head>
      {/* 基础元数据 */}
      <title>{title}</title>
      <meta name="description" content={description} />
      <meta name="keywords" content={keywords} />
      <link rel="canonical" href={canonical} />
      
      {/* Open Graph */}
      <meta property="og:title" content={title} />
      <meta property="og:description" content={description} />
      <meta property="og:type" content="website" />
      <meta property="og:url" content={canonical} />
      <meta property="og:image" content="/og-image.jpg" />
      
      {/* Twitter Card */}
      <meta name="twitter:card" content="summary_large_image" />
      <meta name="twitter:title" content={title} />
      <meta name="twitter:description" content={description} />
      <meta name="twitter:image" content="/twitter-image.jpg" />
      
      {/* 结构化数据 */}
      <script
        type="application/ld+json"
        dangerouslySetInnerHTML={{
          __html: JSON.stringify({
            "@context": "https://schema.org",
            "@type": "WebSite",
            "name": "AI工具导航",
            "description": description,
            "url": canonical
          })
        }}
      />
    </Head>
  );
}

// 页面级SEO配置
export const metadata: Metadata = {
  title: 'AI工具导航 - 发现优质AI工具',
  description: '专业的AI工具导航平台，收录各类优质AI工具，包括AI写作、AI绘画、AI音频等多个分类，帮助您快速找到合适的AI工具。',
  keywords: 'AI工具,人工智能,AI导航,ChatGPT,Midjourney,AI写作,AI绘画',
  openGraph: {
    title: 'AI工具导航 - 发现优质AI工具',
    description: '专业的AI工具导航平台，收录各类优质AI工具',
    type: 'website',
    locale: 'zh_CN',
  },
};
```

### 6.2 性能优化
```typescript
// 图片优化
import Image from 'next/image';

function OptimizedToolIcon({ src, alt }: { src: string; alt: string }) {
  return (
    <Image
      src={src}
      alt={alt}
      width={48}
      height={48}
      priority={false}
      placeholder="blur"
      blurDataURL="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwCdABmX/9k="
      className="rounded-lg"
    />
  );
}

// 代码分割
const HeavyComponent = dynamic(() => import('./HeavyComponent'), {
  loading: () => <ComponentSkeleton />,
  ssr: false
});

// 预加载关键路由
function preloadRoutes() {
  // 预加载工具详情页
  import('./tools/[slug]/page');
  
  // 预加载分类页面
  import('./categories/[category]/page');
}
```

## 7. 错误处理和监控

### 7.1 错误边界实现
```typescript
// 错误边界组件
class ErrorBoundary extends React.Component<
  { children: React.ReactNode; fallback?: React.ComponentType<any> },
  { hasError: boolean; error?: Error }
> {
  constructor(props: any) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    // 错误日志记录
    console.error('Error caught by boundary:', error, errorInfo);
    
    // 发送错误报告
    reportError(error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      const FallbackComponent = this.props.fallback || DefaultErrorFallback;
      return <FallbackComponent error={this.state.error} />;
    }
    
    return this.props.children;
  }
}

// 错误回退组件
function DefaultErrorFallback({ error }: { error?: Error }) {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full bg-white rounded-lg shadow-lg p-6">
        <div className="flex items-center justify-center w-12 h-12 mx-auto bg-red-100 rounded-full mb-4">
          <svg className="w-6 h-6 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16c-.77.833.192 2.5 1.732 2.5z" />
          </svg>
        </div>
        <h3 className="text-lg font-medium text-gray-900 text-center mb-2">
          页面加载出错
        </h3>
        <p className="text-sm text-gray-500 text-center mb-4">
          抱歉，页面遇到了一些问题。请刷新页面重试。
        </p>
        <button
          onClick={() => window.location.reload()}
          className="w-full bg-indigo-600 text-white py-2 px-4 rounded-md hover:bg-indigo-700 transition-colors"
        >
          刷新页面
        </button>
      </div>
    </div>
  );
}
```

### 7.2 性能监控
```typescript
// 性能监控Hook
function usePerformanceMonitoring() {
  useEffect(() => {
    // 监控页面加载性能
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.entryType === 'navigation') {
          const navigationEntry = entry as PerformanceNavigationTiming;
          
          // 记录关键性能指标
          const metrics = {
            FCP: navigationEntry.loadEventEnd - navigationEntry.fetchStart,
            LCP: navigationEntry.loadEventEnd - navigationEntry.fetchStart,
            FID: 0, // 需要通过其他方式测量
            CLS: 0, // 需要通过其他方式测量
          };
          
          // 发送性能数据
          reportPerformanceMetrics(metrics);
        }
      }
    });
    
    observer.observe({ entryTypes: ['navigation', 'paint'] });
    
    return () => observer.disconnect();
  }, []);
}

// Web Vitals监控
function reportWebVitals(metric: any) {
  // 发送到分析服务
  if (typeof window !== 'undefined' && window.gtag) {
    window.gtag('event', metric.name, {
      event_category: 'Web Vitals',
      event_label: metric.id,
      value: Math.round(metric.name === 'CLS' ? metric.value * 1000 : metric.value),
      non_interaction: true,
    });
  }
}
```

## 8. 部署和优化

### 8.1 构建优化配置
```typescript
// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  // 实验性功能
  experimental: {
    appDir: true,
    optimizeCss: true,
  },
  
  // 图片优化
  images: {
    domains: ['example.com'],
    formats: ['image/webp', 'image/avif'],
  },
  
  // 压缩配置
  compress: true,
  
  // 静态导出优化
  trailingSlash: false,
  
  // Webpack配置
  webpack: (config, { buildId, dev, isServer, defaultLoaders, webpack }) => {
    // 优化包大小
    config.optimization.splitChunks = {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
      },
    };
    
    return config;
  },
  
  // 环境变量
  env: {
    ANALYTICS_ID: process.env.ANALYTICS_ID,
  },
};

module.exports = nextConfig;
```

### 8.2 CDN和缓存策略
```typescript
// 静态资源缓存配置
const cacheConfig = {
  // 图片资源
  images: {
    'Cache-Control': 'public, max-age=31536000, immutable'
  },
  
  // CSS/JS文件
  assets: {
    'Cache-Control': 'public, max-age=31536000, immutable'
  },
  
  // HTML页面
  pages: {
    'Cache-Control': 'public, max-age=3600, s-maxage=86400'
  }
};

// Service Worker缓存策略
const swConfig = {
  runtimeCaching: [
    {
      urlPattern: /^https:\/\/fonts\.googleapis\.com\/.*/i,
      handler: 'CacheFirst',
      options: {
        cacheName: 'google-fonts-cache',
        expiration: {
          maxEntries: 10,
          maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
        },
      },
    },
    {
      urlPattern: /\.(?:png|jpg|jpeg|svg|gif|webp)$/i,
      handler: 'CacheFirst',
      options: {
        cacheName: 'images-cache',
        expiration: {
          maxEntries: 100,
          maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
        },
      },
    },
  ],
};
```

这个技术实现方案文档详细描述了AI工具导航首页的完整技术架构和实现细节，为开发团队提供了全面的技术指导。