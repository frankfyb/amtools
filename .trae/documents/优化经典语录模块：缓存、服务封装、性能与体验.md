## 现状与问题
- 服务端：`src/app/api/feishu/classic-quotes/route.ts` 使用文件缓存但无过期控制（见 route.ts:152–158, 165–175），统一 `no-store` 返回。
- 客户端：`src/app/tools/classic-quotes/page.tsx` 60s 强制刷新（page.tsx:66），本地收藏用 `localStorage`（page.tsx:70–75），动画与状态分散在组件内。

## 目标
1) 加入缓存过期与条件请求；2) 封装 Feishu API 服务层与类型；3) 优化渲染与网络；4) 拆分组件与状态；5) 提升加载/错误/动画体验；6) 强化类型与动画质量；7) 提取常量与完善文档。

## 分阶段实施
### Phase 1：缓存策略与服务层
- 缓存 TTL：新增 `FEISHU_CACHE_TTL_MINUTES`（默认 30）。读取本地文件时基于 `payload.updatedAt` 判定是否过期；支持 `refresh=1` 强刷。
- 条件请求：生成并返回 `ETag`（hash of quotes）与 `Last-Modified`，处理 `If-None-Match/If-Modified-Since` 命中场景返回 304。
- 响应头：`Cache-Control: public, max-age=60, stale-while-revalidate=300` 用于前端 SWR。
- 服务封装与类型：
  - 新增 `src/lib/feishu/ClassicQuotesService.ts`（获取 token、fields、records、normalize、hash）。
  - 新增 `src/types/feishu.ts`（`TenantTokenResponse`, `FieldMeta`, `RawRecord`, `Quote`, `Payload`）。
- 路由改造：`route.ts` 仅负责缓存与协议，核心数据流程委托服务层。

### Phase 2：网络与渲染性能
- 拉取策略：用 TTL+SWR 替代固定 60s 强刷；正在拉取时使用 AbortController 取消旧请求；失败重试采用指数退避。
- 组件拆分与 memo：将卡片、工具栏、收藏列表、状态栏与错误面板拆分为子组件，使用 `React.memo`；派生数据用 `useMemo`，事件处理 `useCallback`。
- 动画触发优化：仅在依赖变更时触发；遵守 `prefers-reduced-motion`；后台/非可见时暂停摇摆动画。

### Phase 3：状态管理与体验
- 自定义 Hooks：
  - `useFeishuQuotes({ ttl })`：管理远端拉取、SWR、错误与更新。
  - `useFavorites()`：本地收藏读写，暴露 `isFav/toggle/clear`。
- `useReducer` 合并状态：`loading/err/q/remoteQuotes/favIds/auto/anim/api/slow`。
- 体验：
  - 加载骨架与按钮禁用；错误分层提示（网络/解析/空数据）；离线兜底显示内置语录。
  - 按压反馈与焦点可达性（`focus-visible`、`aria-label`）。

### Phase 4：质量与可持续
- 类型全面覆盖，移除 `any`；ESLint 强化 `exhaustive-deps` 与 `no-explicit-any`；
- 动画质量：统一时长与缓动，确保 `kill()` 清理；打字动画走 timeline；
- 常量提取：环境键、端点、TTL、动画参数、文案与类名进入 `src/lib/constants.ts`；
- 文档：`docs/经典语录模块设计与缓存策略.md` 记录接口约定、缓存命中与测试范围；补充单元与 e2e 用例。

## 关键实现草案（示意）
```ts
// types/feishu.ts
export interface FieldMeta { id: string; name: string; type: string }
export interface RawRecord { record_id: string; fields: Record<string, unknown> }
export interface Quote { id: number; text: string; author: string; category: string }
export interface Payload { source: string; updatedAt: string; schema: FieldMeta[]; records: RawRecord[]; quotes: Quote[]; etag?: string }
```
```ts
// lib/feishu/ClassicQuotesService.ts
export class ClassicQuotesService {
  constructor(private fetchImpl: typeof fetch, private appId: string, private secret: string, private baseToken: string) {}
  async getTenantAccessToken(): Promise<string> {}
  async listFields(token: string): Promise<FieldMeta[]> {}
  async listRecords(token: string): Promise<RawRecord[]> {}
  normalize(records: RawRecord[], fields: FieldMeta[]): Quote[] { return [] }
  buildPayload(quotes: Quote[], fields: FieldMeta[], records: RawRecord[]): Payload { return { source: 'feishu-bitable', updatedAt: new Date().toISOString(), schema: fields, records, quotes } }
  hashQuotes(quotes: Quote[]): string { return '' }
}
```
```ts
// route 缓存 TTL 逻辑
const ttlMs = Number(process.env.FEISHU_CACHE_TTL_MINUTES ?? 30) * 60_000
const cached = await readFilePayload(DATA_FILE)
const fresh = cached && Date.now() - Date.parse(cached.updatedAt) < ttlMs
if (!refresh && fresh) return jsonWith304IfMatch(cached)
```
```tsx
// hooks/useFeishuQuotes.ts
export function useFeishuQuotes(opts: { ttl: number }) {
  // SWR 拉取、错误重试、取消旧请求、返回 quotes/updatedAt/status
}
```
```tsx
// 组件拆分
<StatusBar status={api} updatedAt={updatedAt} />
<Toolbar onToggleFavView={...} onRefresh={...} />
{favView ? <FavList items={favList} onClear={...} /> : <QuoteCard quote={q} onFetch={fetchQuote} onToggleFav={toggleFav} />}
```

## 参考代码位置
- 文件缓存：`src/app/api/feishu/classic-quotes/route.ts:152–158, 165–175`
- 数据拉取：`src/app/tools/classic-quotes/page.tsx:39–56, 62–68`
- 收藏与自动轮换：`page.tsx:70–75, 93–100`
- 动画逻辑：`page.tsx:102–138, 145–167`

## 交付与验证
- 单元测试：服务层分页/令牌/归一化/TTL；
- e2e：加载/刷新/收藏/错误重试/动画可选；
- 指标：首屏时间、请求次数、错误率与缓存命中率；

请确认后我将按阶段实施并提交改动。